import logging
import time
from typing import List, Dict, Type
from .base import ImageProvider

# Ð˜Ð¼Ð¿Ð¾Ñ€Ñ‚Ð¸Ñ€ÑƒÐµÐ¼ Ð²ÑÐµ Ð¿Ñ€Ð¾Ð²Ð°Ð¹Ð´ÐµÑ€Ñ‹
from .playground import PlaygroundProvider
from .flux_klein import FluxKleinProvider
from .qwen import QwenProvider
from .z_image_kieai import ZImageKieAIProvider
from .radames import RadamesProvider
from .pixazo import PixazoProvider
from .leonardo import LeonardoProvider

logger = logging.getLogger(__name__)

logging.getLogger("httpx").setLevel(logging.WARNING)

# ÐŸÑ€Ð¾Ð²Ð°Ð¹Ð´ÐµÑ€Ñ‹, ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ðµ Ð½Ð¸ÐºÐ¾Ð³Ð´Ð° Ð½Ðµ Ð±Ð°Ð½ÑÑ‚ÑÑ (Ð²ÑÐµÐ³Ð´Ð° Ð² Ñ€Ð¾Ñ‚Ð°Ñ†Ð¸Ð¸)
NEVER_BLACKLIST: set[Type[ImageProvider]] = {PixazoProvider}

# Blacklist: ÐºÐ»Ð°ÑÑ Ð¿Ñ€Ð¾Ð²Ð°Ð¹Ð´ÐµÑ€Ð° -> timestamp ÐºÐ¾Ð³Ð´Ð° ÑƒÐ¿Ð°Ð»
# ÐŸÑ€Ð¾Ð²Ð°Ð¹Ð´ÐµÑ€ Ð¸ÑÐºÐ»ÑŽÑ‡Ð°ÐµÑ‚ÑÑ Ð½Ð° 24 Ñ‡Ð°ÑÐ° Ð¿Ð¾ÑÐ»Ðµ Ð¿ÐµÑ€Ð²Ð¾Ð¹ Ð¾ÑˆÐ¸Ð±ÐºÐ¸
_blacklist: Dict[Type[ImageProvider], float] = {}
_BLACKLIST_TTL = 24 * 60 * 60  # ÑÐµÐºÑƒÐ½Ð´


def _is_blacklisted(cls: Type[ImageProvider]) -> bool:
    if cls in NEVER_BLACKLIST:
        return False
    banned_at = _blacklist.get(cls)
    if banned_at is None:
        return False
    if time.time() - banned_at >= _BLACKLIST_TTL:
        del _blacklist[cls]
        logger.info(f"ðŸ”“ [Orchestrator] {cls.__name__} unbanned after 24h cooldown")
        return False
    return True


def _ban(cls: Type[ImageProvider]) -> None:
    if cls in NEVER_BLACKLIST:
        return
    _blacklist[cls] = time.time()
    logger.warning(f"ðŸš« [Orchestrator] {cls.__name__} banned for {_BLACKLIST_TTL // 3600}h")


def generate_image_sync(
        prompt: str,
        negative_prompt: str,
        width: int,
        height: int
) -> bytes:

    # === Ð¡Ð¢Ð ÐÐ¢Ð•Ð“Ð˜Ð¯ ===
    # 1. Ð¡Ð½Ð°Ñ‡Ð°Ð»Ð° Ð¿Ñ€Ð¾Ð±ÑƒÐµÐ¼ ÑÐ°Ð¼Ñ‹Ðµ ÐºÑ€ÑƒÑ‚Ñ‹Ðµ Ð±ÐµÑÐ¿Ð»Ð°Ñ‚Ð½Ñ‹Ðµ (Playground, Flux, Qwen)
    # 2. ÐŸÐ¾Ñ‚Ð¾Ð¼ Ð¿Ñ€Ð¾Ð±ÑƒÐµÐ¼ Ð±Ñ‹ÑÑ‚Ñ€Ñ‹Ðµ/CPU (Radames Lightning)
    # 3. LeonardoAI (ÑƒÐ½Ð¸Ð²ÐµÑ€ÑÐ°Ð»ÑŒÐ½Ñ‹Ð¹)
    # 4. Ð’ ÑÐ°Ð¼Ð¾Ð¼ ÐºÐ¾Ð½Ñ†Ðµ - Ð¿Ð»Ð°Ñ‚Ð½Ñ‹Ð¹/ÑÑ‚Ð°Ð±Ð¸Ð»ÑŒÐ½Ñ‹Ð¹ (Pixazo) â€” Ð½Ð¸ÐºÐ¾Ð³Ð´Ð° Ð½Ðµ Ð±Ð°Ð½Ð¸Ñ‚ÑÑ

    all_providers: List[Type[ImageProvider]] = [
        PlaygroundProvider,    # 1. Ð¢Ð¾Ð¿ ÐºÐ°Ñ‡ÐµÑÑ‚Ð²Ð¾ (45 ÑÐµÐº)
        FluxKleinProvider,     # 2. Ð‘Ñ‹ÑÑ‚Ñ€Ñ‹Ð¹ Ð¸ ÐºÑ€ÑƒÑ‚Ð¾Ð¹ (30 ÑÐµÐº)
        LeonardoProvider,      # 3. Leonardo AI (GPT-1.5 / Nano / SeeDream)
        # QwenProvider,        # 4. Ð£Ð¼Ð½Ñ‹Ð¹, Ð¿Ð¾Ð½Ð¸Ð¼Ð°ÐµÑ‚ ÑÑ†ÐµÐ½Ñ‹ (60 ÑÐµÐº)
        ZImageKieAIProvider,   # 5. Z-Image via kie.ai (120 ÑÐµÐº Ñ‚Ð°Ð¹Ð¼Ð°ÑƒÑ‚)
        # RadamesProvider,     # 6. Ð¡Ð¿Ð¸Ð´ÑÑ‚ÐµÑ€ SDXL Lightning (15 ÑÐµÐº)
        PixazoProvider,        # 7. ÐŸÐžÐ¡Ð›Ð•Ð”ÐÐ˜Ð™ Ð Ð£Ð‘Ð•Ð– (Ð’ÑÐµÐ³Ð´Ð° Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚, Ð½Ðµ Ð±Ð°Ð½Ð¸Ñ‚ÑÑ)
    ]

    active = [cls for cls in all_providers if not _is_blacklisted(cls)]

    skipped = len(all_providers) - len(active)
    logger.info(f"ðŸŽ¬ [Orchestrator] New Request: '{prompt[:40]}...' Size: {width}x{height} "
                f"| Active: {len(active)}/{len(all_providers)} providers"
                + (f" ({skipped} blacklisted)" if skipped else ""))

    errors = []

    for i, cls in enumerate(active, 1):
        provider = cls()
        logger.info(f"ðŸ”„ [Orchestrator] Step {i}/{len(active)}: Launching >>> {provider.name} <<<")

        try:
            result = provider.generate(prompt, negative_prompt, width, height)
            logger.info(f"âœ… [Orchestrator] SUCCESS! Image generated by {provider.name}")
            return result

        except Exception as e:
            err_msg = str(e)

            if "quota" in err_msg.lower() or "429" in err_msg:
                logger.warning(f"[Orchestrator] {provider.name} hit QUOTA/LIMIT. Moving next...")
            elif "timeout" in err_msg.lower():
                logger.warning(f"[Orchestrator] {provider.name} TIMED OUT. Moving next...")
            else:
                logger.error(f"[Orchestrator] {provider.name} FAILED: {err_msg}")

            _ban(cls)
            errors.append(f"{provider.name}: {err_msg}")

    final_error = f"ALL PROVIDERS DEAD. Details: {'; '.join(errors)}"
    logger.critical(final_error)
    raise Exception(final_error)
