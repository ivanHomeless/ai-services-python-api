import logging
import time
from typing import List, Dict
from .base import ImageProvider

# Ð˜Ð¼Ð¿Ð¾Ñ€Ñ‚Ð¸Ñ€ÑƒÐµÐ¼ Ð²ÑÐµ Ð¿Ñ€Ð¾Ð²Ð°Ð¹Ð´ÐµÑ€Ñ‹
from .playground import PlaygroundProvider  # ÐŸÐµÑ€ÐµÐ¸Ð¼ÐµÐ½Ð¾Ð²Ð°Ð»Ð¸ ÐºÐ»Ð°ÑÑ? Ð•ÑÐ»Ð¸ Ð½ÐµÑ‚, Ð¾ÑÑ‚Ð°Ð²ÑŒ HuggingFaceProvider
from .flux_klein import FluxKleinProvider
from .qwen import QwenProvider
from .z_image_kieai import ZImageKieAIProvider
from .radames import RadamesProvider
from .pixazo import PixazoProvider
from .leonardo import LeonardoProvider

# ÐÐ°ÑÑ‚Ñ€Ð°Ð¸Ð²Ð°ÐµÐ¼ Ð»Ð¾Ð³Ð³ÐµÑ€ Ð´Ð»Ñ ÑÑ‚Ð¾Ð³Ð¾ Ñ„Ð°Ð¹Ð»Ð°
logger = logging.getLogger(__name__)

# ÐŸÑ€Ð¸Ð³Ð»ÑƒÑˆÐ°ÐµÐ¼ httpx Ð»Ð¾Ð³Ð¸ (heartbeat 404 Ð¸ Ð¿Ñ€Ð¾Ñ‡Ð¸Ð¹ ÑˆÑƒÐ¼ Ð¾Ñ‚ Gradio Client)
logging.getLogger("httpx").setLevel(logging.WARNING)

# ÐŸÑ€Ð¾Ð²Ð°Ð¹Ð´ÐµÑ€Ñ‹, ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ðµ Ð½Ð¸ÐºÐ¾Ð³Ð´Ð° Ð½Ðµ Ð±Ð°Ð½ÑÑ‚ÑÑ (Ð²ÑÐµÐ³Ð´Ð° Ð² Ñ€Ð¾Ñ‚Ð°Ñ†Ð¸Ð¸)
NEVER_BLACKLIST = {PixazoProvider}

# Blacklist: provider_class -> timestamp ÐºÐ¾Ð³Ð´Ð° ÑƒÐ¿Ð°Ð»
# ÐŸÑ€Ð¾Ð²Ð°Ð¹Ð´ÐµÑ€ Ð¸ÑÐºÐ»ÑŽÑ‡Ð°ÐµÑ‚ÑÑ Ð½Ð° 24 Ñ‡Ð°ÑÐ° Ð¿Ð¾ÑÐ»Ðµ Ð¿ÐµÑ€Ð²Ð¾Ð¹ Ð¾ÑˆÐ¸Ð±ÐºÐ¸
_blacklist: Dict[type, float] = {}
_BLACKLIST_TTL = 24 * 60 * 60  # 24 Ñ‡Ð°ÑÐ° Ð² ÑÐµÐºÑƒÐ½Ð´Ð°Ñ…


def _is_blacklisted(provider: ImageProvider) -> bool:
    cls = type(provider)
    if cls in NEVER_BLACKLIST:
        return False
    banned_at = _blacklist.get(cls)
    if banned_at is None:
        return False
    if time.time() - banned_at >= _BLACKLIST_TTL:
        # TTL Ð¸ÑÑ‚Ñ‘Ðº â€” ÑÐ½Ð¸Ð¼Ð°ÐµÐ¼ Ð±Ð°Ð½
        del _blacklist[cls]
        logger.info(f"ðŸ”“ [Orchestrator] {provider.name} unbanned after 24h cooldown")
        return False
    return True


def _ban(provider: ImageProvider) -> None:
    cls = type(provider)
    if cls in NEVER_BLACKLIST:
        return
    _blacklist[cls] = time.time()
    hours = _BLACKLIST_TTL / 3600
    logger.warning(f"ðŸš« [Orchestrator] {provider.name} banned for {hours:.0f}h")


def generate_image_sync(
        prompt: str,
        negative_prompt: str,
        width: int,
        height: int
) -> bytes:

    # === Ð¡Ð¢Ð ÐÐ¢Ð•Ð“Ð˜Ð¯ ===
    # 1. Ð¡Ð½Ð°Ñ‡Ð°Ð»Ð° Ð¿Ñ€Ð¾Ð±ÑƒÐµÐ¼ ÑÐ°Ð¼Ñ‹Ðµ ÐºÑ€ÑƒÑ‚Ñ‹Ðµ Ð±ÐµÑÐ¿Ð»Ð°Ñ‚Ð½Ñ‹Ðµ (Playground, Flux, Qwen)
    # 2. ÐŸÐ¾Ñ‚Ð¾Ð¼ Ð¿Ñ€Ð¾Ð±ÑƒÐµÐ¼ Ð±Ñ‹ÑÑ‚Ñ€Ñ‹Ðµ/CPU (Radames Lightning)
    # 3. LeonardoAI (ÑƒÐ½Ð¸Ð²ÐµÑ€ÑÐ°Ð»ÑŒÐ½Ñ‹Ð¹)
    # 4. Ð’ ÑÐ°Ð¼Ð¾Ð¼ ÐºÐ¾Ð½Ñ†Ðµ - Ð¿Ð»Ð°Ñ‚Ð½Ñ‹Ð¹/ÑÑ‚Ð°Ð±Ð¸Ð»ÑŒÐ½Ñ‹Ð¹ (Pixazo) â€” Ð½Ð¸ÐºÐ¾Ð³Ð´Ð° Ð½Ðµ Ð±Ð°Ð½Ð¸Ñ‚ÑÑ

    all_providers: List[ImageProvider] = [
        PlaygroundProvider(),  # 1. Ð¢Ð¾Ð¿ ÐºÐ°Ñ‡ÐµÑÑ‚Ð²Ð¾ (45 ÑÐµÐº)
        FluxKleinProvider(),  # 2. Ð‘Ñ‹ÑÑ‚Ñ€Ñ‹Ð¹ Ð¸ ÐºÑ€ÑƒÑ‚Ð¾Ð¹ (30 ÑÐµÐº)
        LeonardoProvider(),    # 3. Leonardo AI (GPT-1.5 / Nano / SeeDream)
        #QwenProvider(),  # 4. Ð£Ð¼Ð½Ñ‹Ð¹, Ð¿Ð¾Ð½Ð¸Ð¼Ð°ÐµÑ‚ ÑÑ†ÐµÐ½Ñ‹ (60 ÑÐµÐº)
        ZImageKieAIProvider(),  # 5. Z-Image via kie.ai (120 ÑÐµÐº Ñ‚Ð°Ð¹Ð¼Ð°ÑƒÑ‚)
        #RadamesProvider(),  # 6. Ð¡Ð¿Ð¸Ð´ÑÑ‚ÐµÑ€ SDXL Lightning (15 ÑÐµÐº)
        PixazoProvider()  # 7. ÐŸÐžÐ¡Ð›Ð•Ð”ÐÐ˜Ð™ Ð Ð£Ð‘Ð•Ð– (Ð’ÑÐµÐ³Ð´Ð° Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚, Ð½Ðµ Ð±Ð°Ð½Ð¸Ñ‚ÑÑ)
    ]

    providers = [p for p in all_providers if not _is_blacklisted(p)]

    skipped = len(all_providers) - len(providers)
    logger.info(f"ðŸŽ¬ [Orchestrator] New Request: '{prompt[:40]}...' Size: {width}x{height} "
                f"| Active: {len(providers)}/{len(all_providers)} providers"
                + (f" ({skipped} blacklisted)" if skipped else ""))

    errors = []

    for i, provider in enumerate(providers, 1):
        logger.info(f"ðŸ”„ [Orchestrator] Step {i}/{len(providers)}: Launching >>> {provider.name} <<<")

        try:
            result = provider.generate(prompt, negative_prompt, width, height)
            logger.info(f"âœ… [Orchestrator] SUCCESS! Image generated by {provider.name}")
            return result

        except Exception as e:
            err_msg = str(e)

            if "quota" in err_msg.lower() or "429" in err_msg:
                logger.warning(f"[Orchestrator] {provider.name} hit QUOTA/LIMIT. Moving next...")
            elif "timeout" in err_msg.lower():
                logger.warning(f"[Orchestrator] {provider.name} TIMED OUT (Queue too long). Moving next...")
            else:
                logger.error(f"[Orchestrator] {provider.name} FAILED: {err_msg}")

            _ban(provider)
            errors.append(f"{provider.name}: {err_msg}")
            continue

    # Ð•ÑÐ»Ð¸ Ñ†Ð¸ÐºÐ» Ð·Ð°ÐºÐ¾Ð½Ñ‡Ð¸Ð»ÑÑ, Ð° Ð¼Ñ‹ Ð·Ð´ÐµÑÑŒ â€” Ð·Ð½Ð°Ñ‡Ð¸Ñ‚ ÑƒÐ¿Ð°Ð» Ð´Ð°Ð¶Ðµ Pixazo
    final_error = f"ALL PROVIDERS DEAD. Details: {'; '.join(errors)}"
    logger.critical(final_error)
    raise Exception(final_error)